# -*- coding: utf-8 -*-
"""Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y8H5Eff-OtU1QpSAgpOV030ScNimkp0t

# 2024 Brazillian Municipal Elections: Which Political Spectrum Was Victorious?  

Electoral behavior is a complex phenomenon influenced by a multitude of social, economic, cultural, and political factors. With advances in data analysis technologies, it has become possible to explore election dynamics more deeply and visually compellingly over time. This is a visualization of the 2024 elections, demonstrating through maps which regions elected mayors from a specific political spectrum.

# 1. Data Collection and Processing  

The data used is available in the [Superior Electoral Court (TSE) open data repository](https://dadosabertos.tse.jus.br/). Since the TSE does not offer API connection, CSV files will be used. To identify the ideology (political spectrum) of each party, a listing was developed based on Bolognesi, Ribeiro, and Codato (2023), taking as an example the list created by @kterra. Lastly, [*shapefiles*](https://en.wikipedia.org/wiki/Shapefile) for Brazilian municipalities were collected from the Brazilian Institute of Geography and Statistics (IBGE) website, in the [territorial mesh repository](https://www.ibge.gov.br/geociencias/organizacao-do-territorio/malhas-territoriais/15774-malhas.html).

## Project Structure

```markdown
├── .data                 # Conjunto de dados brutos e tratados
|-- .shapefiles           # Conjunto de dados geográficos      
├── reports               # Relatórios gerados e documentações analíticas  
├── requirements.txt      # Bibliotecas e dependências do projeto  
└── README.md             # Documentação principal
```
"""

# Necessary libraries

import os
from zipfile import ZipFile
import pandas as pd
import geopandas as gpd
import matplotlib.pyplot as plt
import numpy as np
import requests
import json
from pprint import pprint

# Creation of the Table with Brazilian Political Parties, Their Respective Political Spectrum, and Numbers

partidos = np.array([
    ['PT', 'Left', 13],
    ['PSDB', 'Right', 45],
    ['UNIÃO', 'Right', 44],
    ['MDB', 'Center', 15],
    ['PP', 'Right', 11],
    ['PSD', 'Right', 55],
    ['PL', 'Right', 22],
    ['PSB', 'Left', 40],
    ['PDT', 'Left', 12],
    ['Solidariedade', 'Center', 77],
    ['Republicanos', 'Right', 10],
    ['PSOL', 'Left', 50],
    ['PCdoB', 'Left', 65],
    ['Rede', 'Center', 18],
    ['PV', 'Center', 43],
    ['Cidadania', 'Center', 23],
    ['PODE', 'Right', 19],
    ['DC', 'Right', 27],
    ['PCB', 'Left', 21],
    ['MOBILIZA', 'Right', 33],
    ['PRTB', 'Right', 28],
    ['PMB', 'Right', 35],
    ['UP', 'Left', 80],
    ['PRD', 'Right', 25],
    ['PSTU', 'Left', 16],
    ['PCO', 'Left', 29],
    ['AGIR', 'Left', 36],
    ['NOVO', 'Right', 30],
    ['AVANTE', 'Left', 70]
])

partidos_brasil = pd.DataFrame(partidos, columns=['Partido', 'Espectro', 'Número'])

partidos_brasil = partidos_brasil.sort_values(by='Número', ascending=True) # Ordenação dos partidos por número

"""This script creates a DataFrame containing Brazilian political parties, their respective political spectrums, and numbers.  
It then sorts the DataFrame by the party numbers in ascending order and converts the 'Spectrum' column to a categorical type with a specific order.

### Variables:
- `partidos (np.ndarray)`: A numpy array containing political parties, their spectrums, and numbers.  
- `partidos_brasil (pd.DataFrame)`: A DataFrame created from the 'partidos' array with the columns 'Party', 'Spectrum', and 'Number.'  
- `espec_type (pd.CategoricalDtype)`: A categorical data type for the 'Spectrum' column with a specific order.  

### Steps:
1. Create a numpy array 'partidos' with political parties, their spectrums, and numbers.  
2. Convert the 'partidos' array into a DataFrame called 'partidos_brasil.'  
3. Sort the 'partidos_brasil' DataFrame by the 'Number' column in ascending order.  
4. Define a categorical data type 'espec_type' for the 'Spectrum' column with a specific order.  
5. Convert the 'Spectrum' column in 'partidos_brasil' to the 'espec_type' categorical data type.  
6. Print the sorted and updated 'partidos_brasil' DataFrame.
"""

# Made a categorical type for the political spectrum of the parties
espec_type = pd.CategoricalDtype(categories=['Right', 'Center', 'Left'], ordered=True)

partidos_brasil['Espectro'] = partidos_brasil['Espectro'].astype(espec_type)

print(partidos_brasil)

"""### Detailed Explanation:

1. `pd.CategoricalDtype:`

This is a pandas class that defines a custom categorical data type. Categorical data in pandas is useful for efficiently representing qualitative (categorical) variables.

#### Arguments of `pd.CategoricalDtype`:

- `categories`: A list of categories that the type should include. In the example, they are `['Right', 'Center', 'Left']`.  

- `ordered`: A boolean indicating whether the categories have a logical order (for instance, 'Right' is greater than 'Center,' which is greater than 'Left'). In this example, `ordered=True` defines this order.

#### What does the line do?

`espec_type` is a variable that stores this categorical type configuration.

It indicates that any pandas column or series with this type should:  
- Include only the categories `['Right', 'Center', 'Left']`.  
- Treat these categories as having a logical order: `'Right' < 'Center' < 'Left'`.
"""

partidos_brasil.info()

"""Data files can be download at [Google Drive](https://drive.google.com/drive/folders/1GLH2YuCGg7jm1dwyyiRRhPCHmvkF7IQP?usp=drive_link)"""

# File variables
BR_Municipíos_2023 = 'path/to/BR_Municipíos_2023'  # Define the path to BR_Municipíos_2023
arquivo_resultado_2024 = os.path.join('.data/votacao_candidato_munzona_2024.zip')
arquivo_resultado_2020 = os.path.join('.data/votacao_candidato_munzona_2020.zip')
arquivo_resultado_2016 = os.path.join('.data/votacao_candidato_munzona_2016.zip')
arquivo_BR_mun_shapefile = os.path.join(".shapefiles", "BR_Municipios_2023.shp")

print(os.path.exists(arquivo_BR_mun_shapefile)) # Check if the shapefile exists

# Change the backend of the plotting library to plotly
pd.options.plotting.backend = 'plotly'

# Global variables for the analysis
local = 'BRASIL' # Place of interest, being BRASIL or a specific state
cargo = "Prefeito"  # Position of interest, being Prefeito or Vereador

with ZipFile(arquivo_resultado_2024) as z:
    with z.open(f'votacao_candidato_munzona_2024_{local}.csv') as f:
        resultado_2024 = pd.read_csv(f, sep=';', encoding='latin1', decimal=',')


with ZipFile(arquivo_resultado_2020) as z:
    with z.open(f'votacao_candidato_munzona_2020_{local}.csv') as f:
        resultado_2020 = pd.read_csv(f, sep=';', encoding='latin1', decimal=',')

with ZipFile(arquivo_resultado_2016) as z:
    with z.open(f'votacao_candidato_munzona_2016_{local}.csv') as f:
        resultado_2016 = pd.read_csv(f, sep=';', encoding='latin1', decimal=',')

resultado_2024.info()
resultado_2020.info()
resultado_2016.info()

"""This script reads electoral data from CSV files contained within ZIP archives for the years 2024, 2020, and 2016. The data is loaded into pandas DataFrames, and basic information about each DataFrame is printed.

**Variables**:  
    `arquivo_resultado_2024` (str): Path to the ZIP file containing the 2024 election results.  
    `arquivo_resultado_2020` (str): Path to the ZIP file containing the 2020 election results.  
    `arquivo_resultado_2016` (str): Path to the ZIP file containing the 2016 election results.  
    `local` (str): A variable used to specify the location in the file name.  
    `resultado_2024` (DataFrame): DataFrame containing the 2024 election results.  
    `resultado_2020` (DataFrame): DataFrame containing the 2020 election results.  
    `resultado_2016` (DataFrame): DataFrame containing the 2016 election results.  

**Notes**:  
    - The CSV files are expected to be encoded in 'latin1' and use ';' as the delimiter and ',' as the decimal point.  
    - The script prints the structure and summary information of each DataFrame using the `info()` method.

That's we needs to check for the existence of a shapefile and attempt to load it using GeoPandas.

If the specified shapefile exists, the function attempts to load it into a GeoDataFrame.  
If not, it prints a message indicating the file was not found.

**Variables**  
`BR_mun_shapefile_path` (str): Path to the shapefile.

**Dependencies**  
- `os`: Module for operating system interaction  
- `geopandas` (gpd): Library for geospatial data processing  

**Exceptions**  
`Exception`: Catches any errors during shapefile loading and prints an error message.

**Output**  
- If successful: Prints the first rows of the GeoDataFrame  
- If unsuccessful: Prints an error message or file not found notification  

Key technical terms preserved:
- Shapefile (geospatial vector data format)
- GeoPandas (Python library)
- GeoDataFrame (geospatial dataframe structure)
"""

# Check if shapefile exists
if os.path.exists(arquivo_BR_mun_shapefile):
    try:
        # Carregar o shapefile
        geo_df = gpd.read_file(arquivo_BR_mun_shapefile)
        print(geo_df.head())
    except Exception as e:
        print(f"Erro ao carregar o shapefile: {e}")
else:
    print(f"Arquivo não encontrado: {arquivo_BR_mun_shapefile}")

print(geo_df.info())

# Filtering the shapefile by the place of interest
if local != 'BRASIL':
    geo_df = geo_df[geo_df['NM_UF'] == local]

# Converte a coluna 'NM_MUN' para letras maiúsculas
geo_df['NM_MUN'] = geo_df['NM_MUN'].str.upper()

"""Filters the DataFrame `geo_df` based on the value of `local` and converts the 'NM_MUN' column to uppercase. If `local` is not 'BRASIL', the DataFrame `geo_df` is filtered to include only rows where the 'NM_UF' column matches the value of `local`. Then, the 'NM_MUN' column of `geo_df` is converted to uppercase.

Parameters:
    `geo_df (pd.DataFrame)`: The DataFrame containing geographical data.
    `local (str)`: The location filter. If not 'BRASIL', the DataFrame is filtered by this value.

Returns:
None: The function modifies `geo_df` in place.
"""

# Check if the column 'NR_PARTIDO' is in the same format as the column 'Número' in the results

print(resultado_2016.info())
print(resultado_2020.info())
print(resultado_2024.info())
print(partidos_brasil.info())

def resumo_dataframe(df, colunas):
    print(f"\nResumo do DataFrame '{df.name}' ({df.shape[0]} linhas):")
    for coluna in colunas:
        if coluna in df.columns:
            print(f"Coluna: {coluna}")
            print(f"  - dtype: {df[coluna].dtype}")
        else:
            print(f"A coluna '{coluna}' não existe no DataFrame.")

# Adiciona o atributo 'name' aos DataFrames
resultado_2016.name = 'resultado_2016'
resultado_2020.name = 'resultado_2020'
resultado_2024.name = 'resultado_2024'
partidos_brasil.name = 'partidos_brasil'

# Verificação dos tipos de dados das colunas de interesse
colunas_interesse = ['NR_PARTIDO', 'Número']
dataframes = [resultado_2016, resultado_2020, resultado_2024, partidos_brasil]

for df in dataframes:
    resumo_dataframe(df, colunas_interesse)

# Verificação dos tipos de dados das colunas de interesse
colunas_interesse = ['NR_PARTIDO', 'Número']
dataframes = [resultado_2016, resultado_2020, resultado_2024, partidos_brasil]

for df in dataframes:
    resumo_dataframe(df, colunas_interesse)

# Change party number to integer
partidos_brasil['Número'] = partidos_brasil['Número'].astype(int)

print(partidos_brasil['Número'].dtype) # Check if the column is in the correct format

"""## 2. Analysis of Election Results by Political Spectrum

After obtaining the data, an analysis of the data by political spectrum will be conducted. To do this, the election results will be related to the political spectrum of the party, with the total vote being those obtained by the mayoral candidates from each party.
"""

# Merge the results with the parties espectrums

resultado_2016 = pd.merge(resultado_2016, partidos_brasil[['Número', 'Espectro']], left_on='NR_PARTIDO', right_on='Número')
resultado_2016.drop(columns=['NR_PARTIDO'], inplace=True)
print(resultado_2016.info())

resultado_2020 = pd.merge(resultado_2020, partidos_brasil[['Número', 'Espectro']], left_on='NR_PARTIDO', right_on='Número')
resultado_2020.drop(columns=['NR_PARTIDO'], inplace=True)
print(resultado_2020.info())

resultado_2024 = pd.merge(resultado_2024, partidos_brasil[['Número', 'Espectro']], left_on='NR_PARTIDO', right_on='Número')
resultado_2024.drop(columns=['NR_PARTIDO'], inplace=True)
print(resultado_2024.info())

"""This script processes electoral data to create a DataFrame with valid votes by political spectrum and party for the first round of the 2024 elections. It then identifies the winning political spectrum in each municipality.

Steps:
1. Filter the `resultado_2024` DataFrame to include only rows where:
    - The position (`DS_CARGO`) matches the specified `cargo`.
    - The election round (`NR_TURNO`) is 1.
    - The candidate's status (`DS_SIT_TOT_TURNO`) is 'ELEITO'.
2. Group the filtered data by municipality code (`CD_MUNICIPIO`), political spectrum (`Espectro`), party acronym (`SG_PARTIDO`), and candidate number (`Número`).
3. Aggregate the grouped data to get the first occurrence of municipality name (`NM_MUNICIPIO`) and state acronym (`SG_UF`), and sum the valid nominal votes (`QT_VOTOS_NOMINAIS_VALIDOS`).
4. Reset the index of the resulting DataFrame.
5. Identify the winning political spectrum in each municipality by selecting the row with the maximum valid nominal votes (`QT_VOTOS_NOMINAIS_VALIDOS`) for each municipality.
6. Reset the index of the resulting DataFrame to get the final DataFrame `espectro_vencedor_2024_turno1`.

Returns:
     DataFrame: A DataFrame containing the winning political spectrum in each municipality for the first round of the 2024 elections.
"""

# Creating a DataFrame with valid votes by political spectrum and party for the first round

votos_espectro_2024_turno1 = resultado_2024[
    (resultado_2024['DS_CARGO'] == cargo) &
    (resultado_2024['NR_TURNO'] == 1) &
    (resultado_2024['DS_SIT_TOT_TURNO'] == 'ELEITO')
].groupby(
    ['CD_MUNICIPIO', 'Espectro', 'SG_PARTIDO', 'Número'],
    observed=True
).agg({
    'NM_MUNICIPIO': 'first',
    'SG_UF': 'first',
    'QT_VOTOS_NOMINAIS_VALIDOS': 'sum'
}).reset_index()

espectro_vencedor_2024_turno1 = votos_espectro_2024_turno1.loc[votos_espectro_2024_turno1.groupby(['CD_MUNICIPIO'])['QT_VOTOS_NOMINAIS_VALIDOS'].idxmax()].reset_index(drop=True)

espectro_vencedor_2024_turno1

"""1. **Data Filtering**:
   - We select only the records corresponding to the political position of interest (`DS_CARGO == cargo`), the 1st round of the election (`NR_TURNO == 1`), and with elected status (`DS_SIT_TOTAL_TURNO`).

2. **Data Grouping**:
   - We group the records by municipality (`CD_MUNICIPIO`), political spectrum (`Espectro`), political party (`SG_PARTIDO`), and candidate number (`Número`).
   - During the grouping, we perform the following aggregations:
     - Retain the first municipality name (`NM_MUNICIPIO`) and state abbreviation (`SG_UF`).
     - Calculate the sum of valid nominal votes (`QT_VOTOS_NOMINAIS_VALIDOS`) in each group.

3. **Identification of the Winning Spectrum**:
   - After grouping, we determine the political spectrum with the highest number of valid votes in each municipality.
   - This is done using `groupby` by municipality and selecting the index of the highest valid vote count with `idxmax`.

4. **Formatting the Result**:
   - We reset the index of the resulting DataFrame to keep it clean and organized.
   - The final result contains information about the winning political spectrum in each municipality, including the party, candidate number, municipality name, state abbreviation, and total valid votes.

This code facilitates the analysis of election results by consolidating the most relevant data into a single DataFrame.

This script processes electoral data to create a DataFrame with valid votes by political spectrum and party for the first round of the 2024 elections. It then identifies the winning political spectrum in each municipality.

Steps:
1. Filter the `resultado_2024` DataFrame to include only rows where:
    - The position (`DS_CARGO`) matches the specified `cargo`.
    - The election round (`NR_TURNO`) is 2.
    - The candidate's status (`DS_SIT_TOT_TURNO`) is 'ELEITO'.
2. Group the filtered data by municipality code (`CD_MUNICIPIO`), political spectrum (`Espectro`), party acronym (`SG_PARTIDO`), and candidate number (`Número`).
3. Aggregate the grouped data to get the first occurrence of municipality name (`NM_MUNICIPIO`) and state acronym (`SG_UF`), and sum the valid nominal votes (`QT_VOTOS_NOMINAIS_VALIDOS`).
4. Reset the index of the resulting DataFrame.
5. Identify the winning political spectrum in each municipality by selecting the row with the maximum valid nominal votes (`QT_VOTOS_NOMINAIS_VALIDOS`) for each municipality.
6. Reset the index of the resulting DataFrame to get the final DataFrame `espectro_vencedor_2024_turno2`.

Returns:
     
DataFrame: A DataFrame containing the winning political spectrum in each municipality for the first round of the 2024 elections.
"""

# Creating a DataFrame with valid votes by political spectrum and party for the second round

votos_espectro_2024_turno2 = resultado_2024[
    (resultado_2024['DS_CARGO'] == cargo) &
    (resultado_2024['NR_TURNO'] == 2) &
    (resultado_2024['DS_SIT_TOT_TURNO'] == 'ELEITO')
].groupby(
    ['CD_MUNICIPIO', 'Espectro', 'SG_PARTIDO', 'Número'],
    observed=True
).agg({
    'NM_MUNICIPIO': 'first',
    'SG_UF': 'first',
    'QT_VOTOS_NOMINAIS_VALIDOS': 'sum'
}).reset_index()

espectro_vencedor_2024_turno2 = votos_espectro_2024_turno2.loc[votos_espectro_2024_turno2.groupby(['CD_MUNICIPIO'])['QT_VOTOS_NOMINAIS_VALIDOS'].idxmax()].reset_index(drop=True)

espectro_vencedor_2024_turno2

votos_espectro_2020_turno1 = resultado_2020[
    (resultado_2020['DS_CARGO'] == cargo) &
    (resultado_2020['NR_TURNO'] == 1) &
    (resultado_2020['DS_SIT_TOT_TURNO'] == 'ELEITO')
].groupby(
    ['CD_MUNICIPIO', 'Espectro', 'SG_PARTIDO', 'Número'],
    observed=True
).agg({
    'NM_MUNICIPIO': 'first',
    'SG_UF': 'first',
    'QT_VOTOS_NOMINAIS_VALIDOS': 'sum'
}).reset_index()

espectro_vencedor_2020_turno1 = votos_espectro_2020_turno1.loc[votos_espectro_2020_turno1.groupby(['CD_MUNICIPIO'])['QT_VOTOS_NOMINAIS_VALIDOS'].idxmax()].reset_index(drop=True)

espectro_vencedor_2020_turno1

votos_espectro_2020_turno2 = resultado_2020[
    (resultado_2020['DS_CARGO'] == cargo) &
    (resultado_2020['NR_TURNO'] == 2) &
    (resultado_2020['DS_SIT_TOT_TURNO'] == 'ELEITO')
].groupby(
    ['CD_MUNICIPIO', 'Espectro', 'SG_PARTIDO', 'Número'],
    observed=True
).agg({
    'NM_MUNICIPIO': 'first',
    'SG_UF': 'first',
    'QT_VOTOS_NOMINAIS_VALIDOS': 'sum'
}).reset_index()

espectro_vencedor_2020_turno2 = votos_espectro_2020_turno2.loc[votos_espectro_2020_turno2.groupby(['CD_MUNICIPIO'])['QT_VOTOS_NOMINAIS_VALIDOS'].idxmax()].reset_index(drop=True)

espectro_vencedor_2020_turno2

"""An important detail regarding the 2016 results is that only the total nominal votes are available. Therefore, for analysis purposes, this total was considered as valid votes."""

print(resultado_2016.info())

votos_espectro_2016_turno1 = resultado_2016[
    (resultado_2016['DS_CARGO'] == cargo) &
    (resultado_2016['NR_TURNO'] == 1) &
    (resultado_2016['DS_SIT_TOT_TURNO'] == 'ELEITO')
].groupby(
    ['CD_MUNICIPIO', 'Espectro', 'SG_PARTIDO', 'Número'],
    observed=True
).agg({
    'NM_MUNICIPIO': 'first',
    'SG_UF': 'first',
    'QT_VOTOS_NOMINAIS': 'sum'
}).reset_index()

espectro_vencedor_2016_turno1 = votos_espectro_2016_turno1.loc[votos_espectro_2016_turno1.groupby(['CD_MUNICIPIO'])['QT_VOTOS_NOMINAIS'].idxmax()].reset_index(drop=True)

espectro_vencedor_2016_turno1

votos_espectro_2016_turno2 = resultado_2016[
    (resultado_2016['DS_CARGO'] == cargo) &
    (resultado_2016['NR_TURNO'] == 2) &
    (resultado_2016['DS_SIT_TOT_TURNO'] == 'ELEITO')
].groupby(
    ['CD_MUNICIPIO', 'Espectro', 'SG_PARTIDO', 'Número'],
    observed=True
).agg({
    'NM_MUNICIPIO': 'first',
    'SG_UF': 'first',
    'QT_VOTOS_NOMINAIS': 'sum'
}).reset_index()

espectro_vencedor_2016_turno2 = votos_espectro_2016_turno2.loc[votos_espectro_2016_turno2.groupby(['CD_MUNICIPIO'])['QT_VOTOS_NOMINAIS'].idxmax()].reset_index(drop=True)

espectro_vencedor_2016_turno2

"""Concatenates dataframes containing political spectrum information for election winners from different rounds.

Each year's dataframe is created by combining data from first and second rounds of elections.
The concatenation is performed vertically (stacking), with reset index.

**Parameters**:

`espectro_vencedor_{YEAR}_turno1 : pandas.DataFrame`: DataFrame containing first round winners' political spectrum for specified year
`espectro_vencedor_{YEAR}_turno2 : pandas.DataFrame`: DataFrame containing second round winners' political spectrum for specified year

**Returns**:

`espectro_vencedor_{YEAR} : pandas.DataFrame`: Combined DataFrame with election winners' political spectrum for both rounds
"""

espectro_vencedor_2016 = pd.concat([espectro_vencedor_2016_turno1, espectro_vencedor_2016_turno2], ignore_index=True)
espectro_vencedor_2020 = pd.concat([espectro_vencedor_2020_turno1, espectro_vencedor_2020_turno2], ignore_index=True)
espectro_vencedor_2024 = pd.concat([espectro_vencedor_2024_turno1, espectro_vencedor_2024_turno2], ignore_index=True)

"""## 2.1. Merging IBGE and TSE data

Some municipalities have different spellings in the TSE compared to those registered in the IBGE, which can cause discrepancies when generating analysis data. Therefore, it is important to verify the spelling based on IBGE data first. For this, a JSON file with the names of Brazilian municipalities will be imported.
"""

# URL path to the IBGE API
url = 'https://servicodados.ibge.gov.br/api/v1/localidades/municipios'

# Optional parameters
params = {
    'orderBy': 'nome' # Ordenar por nome do município
}

try:

    # Made the get request
    response = requests.get(url, params=params)

    # Checks if the request was successful
    if response.status_code == 200:
        # Extracting the JSON data
        mun_ibge = response.json()

        # Printing the JSON data
        pprint(mun_ibge)

        with open('municipios_ibge.json', 'w', encoding='utf-8') as f:
            json.dump(mun_ibge, f, ensure_ascii=False, indent=2)

    else:
        print(f"Erro na requisição: {response.status_code}")

except requests.exceptions.RequestException as e:
    print(f"Erro na conexão: {e}")

"""This script fetches data from the IBGE API for Brazilian municipalities, orders them by name, and saves the data in a JSON file.

Modules:
- `requests`: To make HTTP requests to the IBGE API.
- `json`: To handle JSON data.
- `pprint`: To print JSON data in a readable format.

Variables:
- url (str): The base URL of the IBGE API.
- params (dict): Optional parameters for the API request, in this case, ordering by municipality name.
- response (requests.Response): The response object from the API request.
- mun_ibge (list): The list of municipality data extracted from the API response.

Exceptions:
- `requests.exceptions.RequestException`: Handles any exceptions that occur during the API request.

Usage: Run the script to fetch municipality data from the IBGE API, print it, and save it to 'municipios_ibge.json'.
"""

# Create a dataframe with the names of the municipalities and their respective UF

with open('municipios_ibge.json', 'r', encoding='utf-8') as f:
    mun_ibge = json.load(f)

municipios = pd.DataFrame([{
    'id': mun['id'],
    'mun': mun['nome'],
    'uf': mun['microrregiao']['mesorregiao']['UF']['sigla']
} for mun in mun_ibge])

municipios['mun'] = municipios['mun'].str.upper()

# Municipalities from TSE
mun_tse = resultado_2024.groupby(resultado_2024['CD_MUNICIPIO']).first().reset_index()[['CD_MUNICIPIO', 'NM_MUNICIPIO', 'SG_UF']]
mun_tse

"""There are different spellings for some municipalities when comparing IBGE and TSE data. Therefore, it is necessary to standardize them."""

print(mun_tse.columns)

len(municipios), len(mun_tse)

# Function for check if the names of the municipalities are the same

import unidecode

def padronizar_nome(nome):
    """
    Standardizes a name by removing extra whitespace, converting to lowercase,
    and removing accents and special characters.

    Args:
        nome (str): The name to be standardized.

    Returns:
        str: The standardized name.
    """
    nome = nome.strip()  # Remove espaços em branco extras
    nome = nome.lower()  # Converte para letras minúsculas
    nome = unidecode.unidecode(nome)  # Remove acentos e caracteres especiais
    return nome

# Aplicar a função de padronização aos nomes dos municípios
municipios['mun_padronizado'] = municipios['mun'].apply(padronizar_nome)
mun_tse['NM_MUNICIPIO_padronizado'] = mun_tse['NM_MUNICIPIO'].apply(padronizar_nome)

# Verificar se os municípios do df_28 estão no df_29
municipios['match'] = municipios['mun_padronizado'].isin(mun_tse['NM_MUNICIPIO_padronizado'])

# Exibir o resultado
print(municipios)

cidades_diferentes = municipios[municipios['match'] == False]

# Dictionary with the names of the municipalities to be updated

cidades_excluir = ['BRASILIA', 'FERNANDO DE NORONHA']

dicionario_tse = {
    'AÇU': 'ASSÚ',
    'ARÊS': 'AREZ',
    'CAMACAN': 'CAMACÃ',
    'JANUÁRIO CICCO': 'BOA SAÚDE',
    'OLHOS-D\'ÁGUA': 'OLHOS D\'ÁGUA',
}

# Update the names of the municipalities
for key, value in dicionario_tse.items():
	municipios.loc[municipios['mun'] == key.upper(), 'mun'] = value.upper()

municipios = municipios[~municipios['mun'].isin(cidades_excluir)]

# Merging the municipalities from IBGE with the TSE municipalities

municipios_final = pd.merge(municipios, mun_tse, left_on=['mun', 'uf'], right_on=['NM_MUNICIPIO', 'SG_UF'], how='inner')
municipios_final = municipios_final[['id', 'mun', 'uf', 'CD_MUNICIPIO']]
municipios_final

"""## 2.2. Link the shapefile files with the TSE codes and the names of the municipalities

To organize the exact location of the municipalities in order to map the regions and the winning political spectrum.
"""

# Merging the shapefile with the municipalities

# Verificação dos tipos de dados
print(geo_df.dtypes)

# Alteração do código do município no dataframe compilado do IBGE para object
municipios['id'] = municipios['id'].astype(str)

merged_map = geo_df.merge(municipios, left_on='CD_MUN', right_on='id', how='inner')

merged_map

"""# 3. Creation of Maps with Election Results

Now maps will be developed with the election results to identify the winning spectrums in the regions of the country. We already have in the dataframes `espectro_vencedor_2016`, `espectro_vencedor_2020`, and `espectro_vencedor_2024` which parties and spectrums won the elections.

Let's merge the geographic data with the results.
"""

# Merging municipalities by the TSE code

print(espectro_vencedor_2016.dtypes)
print(espectro_vencedor_2020.dtypes)
print(espectro_vencedor_2024.dtypes)
print(municipios_final.dtypes)

espectro_ibge_venc_2016 = pd.merge(espectro_vencedor_2016, municipios_final, left_on='CD_MUNICIPIO', right_on='CD_MUNICIPIO', how='inner')
espectro_ibge_venc_2020 = pd.merge(espectro_vencedor_2020, municipios_final, left_on='CD_MUNICIPIO', right_on='CD_MUNICIPIO', how='inner')
espectro_ibge_venc_2024 = pd.merge(espectro_vencedor_2024, municipios_final, left_on='CD_MUNICIPIO', right_on='CD_MUNICIPIO', how='inner')

# Merging the results with the shapefile

print(espectro_ibge_venc_2016.dtypes)
print(espectro_ibge_venc_2020.dtypes)
print(espectro_ibge_venc_2024.dtypes)
print(merged_map.dtypes)

# Transform the 'id' column to integer
merged_map['id'] = merged_map['id'].astype(int)

# Merging the results with the shapefile
espectro_ibge_venc_2016_map = merged_map.merge(espectro_ibge_venc_2016, left_on='id', right_on='id', how='inner')
espectro_ibge_venc_2020_map = merged_map.merge(espectro_ibge_venc_2020, left_on='id', right_on='id', how='inner')
espectro_ibge_venc_2024_map = merged_map.merge(espectro_ibge_venc_2024, left_on='id', right_on='id', how='inner')

# Ploting the results

fig, ax = plt.subplots(1, 3, figsize=(20, 10))
ax[0].set_title(f'Eleições Municipais 2016 - {local} para {cargo}', color='black', fontsize=16)
ax[1].set_title(f'Eleições Municipais 2020 - {local} para {cargo}', color='black', fontsize=16)
ax[2].set_title(f'Eleições Municipais 2024 - {local} para {cargo}', color='black', fontsize=16)

espectro_ibge_venc_2016_map.plot(column='Espectro', cmap='viridis', legend=True, ax=ax[0])
espectro_ibge_venc_2020_map.plot(column='Espectro', cmap='viridis', legend=True, ax=ax[1])
espectro_ibge_venc_2024_map.plot(column='Espectro', cmap='viridis', legend=True, ax=ax[2])